# backend/routers/generate_recipe_router.py

import os
import json
from typing import List

import requests
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel

from google.oauth2 import service_account
from google.auth.transport.requests import Request as GoogleAuthRequest


router = APIRouter(prefix="/generate", tags=["Generate Recipe"])


# ---------- Request / Response Models ----------
class GenerateRecipeRequest(BaseModel):
    ingredients: List[str]   # List of ingredient names provided by the user


class GenerateRecipeResponse(BaseModel):
    ingredients: List[str]   # Echo of input ingredients
    recipe_raw: str          # Recipe JSON text generated by the model
    raw_vertex: dict         # Full Vertex response (optional for debugging)


# ---------- Utility Functions (aligned with scan_router) ----------
def _get_vertex_access_token() -> str:
    """
    Retrieve a Google Cloud access token using a Service Account JSON.

    Required environment variables:
    - GOOGLE_APPLICATION_CREDENTIALS
    """
    cred_path = os.getenv("GOOGLE_APPLICATION_CREDENTIALS")
    if not cred_path:
        raise HTTPException(status_code=500, detail="GOOGLE_APPLICATION_CREDENTIALS is not configured")

    try:
        scopes = ["https://www.googleapis.com/auth/cloud-platform"]
        creds = service_account.Credentials.from_service_account_file(
            cred_path, scopes=scopes
        )
        creds.refresh(GoogleAuthRequest())
        return creds.token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to obtain Google access token: {e}")


def _extract_json_from_text(text: str) -> str:
    """
    Sometimes the model wraps JSON output in ```json ... ``` or ``` ... ``` blocks.
    This function strips those wrappers and returns clean JSON text.
    """
    text = text.strip()
    if text.startswith("```"):
        lines = text.splitlines()
        if len(lines) >= 2 and lines[0].startswith("```"):
            if lines[-1].startswith("```"):
                lines = lines[1:-1]
            else:
                lines = lines[1:]
        text = "\n".join(lines).strip()
    return text


# ---------- Main Endpoint: Generate a recipe based on ingredient list ----------
@router.post("/ingredients", response_model=GenerateRecipeResponse)
async def generate_recipe_from_ingredients(body: GenerateRecipeRequest):
    """
    Given a list of ingredients (typically from scan_router),
    generate a single recipe using Vertex AI Gemini.

    Request:
        POST /generate/ingredients
        Body (JSON):
        {
            "ingredients": ["chicken breast", "broccoli", "olive oil", "garlic"]
        }
    """

    project_id = os.getenv("GCP_PROJECT_ID")
    location = os.getenv("GCP_LOCATION", "us-central1")

    if not project_id:
        raise HTTPException(status_code=500, detail="GCP_PROJECT_ID is not configured")

    # 1. Get access token (same method as scan_router)
    access_token = _get_vertex_access_token()

    # 2. Build Vertex Gemini API request
    model = "gemini-2.5-flash"
    url = (
        f"https://{location}-aiplatform.googleapis.com/v1/"
        f"projects/{project_id}/locations/{location}/publishers/google/"
        f"models/{model}:generateContent"
    )

    ingredients_list_str = ", ".join(body.ingredients) if body.ingredients else "(no ingredients provided)"

    prompt = f"""
You are a professional home cooking assistant. Based on the list of available ingredients below,
create a **single recipe** suitable for everyday home cooking.

Available ingredients: {ingredients_list_str}

Requirements:
1. Prioritize using the provided ingredients. Basic seasonings (salt, sugar, soy sauce, pepper, etc.) may be added, but do not introduce unrelated complex ingredients.
2. Output *one* complete recipe—not multiple recipes.
3. The recipe should be suitable for 1–2 servings and use simple, practical cooking steps.

Please output the recipe **strictly in JSON format** with the following structure:

{{
  "title": "Garlic Chicken with Broccoli",
  "servings": 2,
  "ingredients": [
    {{
      "name": "chicken breast",
      "amount": 200,
      "unit": "g"
    }},
    {{
      "name": "broccoli",
      "amount": 150,
      "unit": "g"
    }},
    {{
      "name": "garlic",
      "amount": 3,
      "unit": "cloves"
    }},
    {{
      "name": "olive oil",
      "amount": 1,
      "unit": "tbsp"
    }},
    {{
      "name": "salt",
      "amount": 1,
      "unit": "tsp"
    }}
  ],
  "steps": [
    "Step 1: Prepare the ingredients...",
    "Step 2: Heat the pan and add olive oil...",
    "Step 3: Add the chicken and stir-fry until the color changes...",
    "Step 4: Add the broccoli and seasonings, then cook until done..."
  ],
  "estimated_time_minutes": 25,
  "difficulty": "easy"
}}

Field descriptions:
- title: Recipe name
- servings: Number of servings (integer)
- ingredients: Array of objects, each containing name, amount, and unit
- steps: Array of step-by-step instructions
- estimated_time_minutes: Estimated total time required
- difficulty: "easy", "medium", or "hard"

Important:
- Return **only** JSON—no explanations or extra text.
- Do not include comments or additional fields.
    """.strip()

    payload = {
        "contents": [
            {
                "role": "user",
                "parts": [
                    {"text": prompt},
                ],
            }
        ],
        "generationConfig": {
            "temperature": 0.6,  # More creativity
        },
    }

    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json; charset=utf-8",
    }

    # 3. Call Vertex API
    resp = requests.post(url, headers=headers, json=payload, timeout=60)
    if resp.status_code != 200:
        raise HTTPException(status_code=500, detail=resp.text)

    data = resp.json()

    # 4. Extract the model-generated text
    try:
        reply_text = data["candidates"][0]["content"]["parts"][0]["text"]
    except Exception:
        raise HTTPException(status_code=500, detail="Unexpected Vertex response format")

    # 5. Clean potential ```json wrappers
    cleaned_recipe_json = _extract_json_from_text(reply_text)

    # Optionally validate JSON
    try:
        json.loads(cleaned_recipe_json)
    except json.JSONDecodeError:
        raise HTTPException(
            status_code=500,
            detail=f"Vertex returned invalid JSON: {cleaned_recipe_json[:200]}..."
        )

    return GenerateRecipeResponse(
        ingredients=body.ingredients,
        recipe_raw=cleaned_recipe_json,
        raw_vertex=data,
    )